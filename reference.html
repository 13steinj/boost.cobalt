<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.20">
<meta name="author" content="Klemens Morgenstern">
<title>Documentation boost.async</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.square{list-style-type:square}
ul.circle ul:not([class]),ul.disc ul:not([class]),ul.square ul:not([class]){list-style:inherit}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:first-child,.sidebarblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child,.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,td.hdlist1,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
pre.rouge table td { padding: 5px; }
pre.rouge table pre { margin: 0; }
pre.rouge .cm {
  color: #999988;
  font-style: italic;
}
pre.rouge .cp {
  color: #999999;
  font-weight: bold;
}
pre.rouge .c1 {
  color: #999988;
  font-style: italic;
}
pre.rouge .cs {
  color: #999999;
  font-weight: bold;
  font-style: italic;
}
pre.rouge .c, pre.rouge .ch, pre.rouge .cd, pre.rouge .cpf {
  color: #999988;
  font-style: italic;
}
pre.rouge .err {
  color: #a61717;
  background-color: #e3d2d2;
}
pre.rouge .gd {
  color: #000000;
  background-color: #ffdddd;
}
pre.rouge .ge {
  color: #000000;
  font-style: italic;
}
pre.rouge .gr {
  color: #aa0000;
}
pre.rouge .gh {
  color: #999999;
}
pre.rouge .gi {
  color: #000000;
  background-color: #ddffdd;
}
pre.rouge .go {
  color: #888888;
}
pre.rouge .gp {
  color: #555555;
}
pre.rouge .gs {
  font-weight: bold;
}
pre.rouge .gu {
  color: #aaaaaa;
}
pre.rouge .gt {
  color: #aa0000;
}
pre.rouge .kc {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kd {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kn {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kp {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kr {
  color: #000000;
  font-weight: bold;
}
pre.rouge .kt {
  color: #445588;
  font-weight: bold;
}
pre.rouge .k, pre.rouge .kv {
  color: #000000;
  font-weight: bold;
}
pre.rouge .mf {
  color: #009999;
}
pre.rouge .mh {
  color: #009999;
}
pre.rouge .il {
  color: #009999;
}
pre.rouge .mi {
  color: #009999;
}
pre.rouge .mo {
  color: #009999;
}
pre.rouge .m, pre.rouge .mb, pre.rouge .mx {
  color: #009999;
}
pre.rouge .sa {
  color: #000000;
  font-weight: bold;
}
pre.rouge .sb {
  color: #d14;
}
pre.rouge .sc {
  color: #d14;
}
pre.rouge .sd {
  color: #d14;
}
pre.rouge .s2 {
  color: #d14;
}
pre.rouge .se {
  color: #d14;
}
pre.rouge .sh {
  color: #d14;
}
pre.rouge .si {
  color: #d14;
}
pre.rouge .sx {
  color: #d14;
}
pre.rouge .sr {
  color: #009926;
}
pre.rouge .s1 {
  color: #d14;
}
pre.rouge .ss {
  color: #990073;
}
pre.rouge .s, pre.rouge .dl {
  color: #d14;
}
pre.rouge .na {
  color: #008080;
}
pre.rouge .bp {
  color: #999999;
}
pre.rouge .nb {
  color: #0086B3;
}
pre.rouge .nc {
  color: #445588;
  font-weight: bold;
}
pre.rouge .no {
  color: #008080;
}
pre.rouge .nd {
  color: #3c5d5d;
  font-weight: bold;
}
pre.rouge .ni {
  color: #800080;
}
pre.rouge .ne {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nf, pre.rouge .fm {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nl {
  color: #990000;
  font-weight: bold;
}
pre.rouge .nn {
  color: #555555;
}
pre.rouge .nt {
  color: #000080;
}
pre.rouge .vc {
  color: #008080;
}
pre.rouge .vg {
  color: #008080;
}
pre.rouge .vi {
  color: #008080;
}
pre.rouge .nv, pre.rouge .vm {
  color: #008080;
}
pre.rouge .ow {
  color: #000000;
  font-weight: bold;
}
pre.rouge .o {
  color: #000000;
  font-weight: bold;
}
pre.rouge .w {
  color: #bbbbbb;
}
pre.rouge {
  background-color: #f8f8f8;
}
</style>
<style>.toc-current{font-weight: bold;} .toc-root{font-family: "Open Sans","DejaVu Sans",sans-serif;
                       font-size: 0.9em;} #content{display: flex; flex-direction: column; flex: 1 1 auto;}
             .nav-footer{text-align: center; margin-top: auto;}
             .nav-footer > p > a {white-space: nowrap;}</style>
</head>
<body id="reference" class="article toc2 toc-left">
<div id="header">
<h1>Documentation boost.async</h1>
<div class="details">
<span id="author" class="author">Klemens Morgenstern</span><br>
<span id="email" class="email"><a href="mailto:klemens.morgenstern@gmx.net">klemens.morgenstern@gmx.net</a></span><br>
<span id="revnumber">version 0.1,</span>
<span id="revdate">29.01.2023</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<p><span class="toc-root"><a href="index.html">Documentation boost.async</a></span></p><ul class="sectlevel1">
<li><a href="overview.html">Overview</a>
</li>
<li><a href="motivation.html">Motivation</a>
</li>
<li><a href="coroutine_primer.html">Coroutine Primer</a>
</li>
<li><a href="tour.html">Tour</a>
</li>
<li><a href="tutorial.html">Tutorial</a>
</li>
<li><a href="design.html">Design</a>
</li>
<li><a href="reference.html"><span class="toc-current">Reference</span></a>
<ul class="sectlevel2">
<li><a href="reference.html#main">async/main.hpp</a>
<ul class="sectlevel3">
<li><a href="reference.html#executor">Executor</a>
</li>
<li><a href="reference.html#memory_resource">Memory Resource</a>
</li>
<li><a href="reference.html#main-promise">Promise</a>
</li>
<li><a href="reference.html#specification">Specification</a>
</li>
</ul>
</li>
<li><a href="reference.html#promise">async/promise.hpp</a>
<ul class="sectlevel3">
<li><a href="reference.html#executor_2">Executor</a>
</li>
<li><a href="reference.html#memory_resource_2">Memory Resource</a>
</li>
<li><a href="reference.html#promise-outline">Outline</a>
</li>
<li><a href="reference.html#promise-promise">Promise</a>
</li>
</ul>
</li>
<li><a href="reference.html#generator">async/generator.hpp</a>
<ul class="sectlevel3">
<li><a href="reference.html#initial">Lazy</a>
</li>
<li><a href="reference.html#generator-executor">Executor</a>
</li>
<li><a href="reference.html#generator-allocator">Memory Resource</a>
</li>
<li><a href="reference.html#generator-outline">Outline</a>
</li>
<li><a href="reference.html#generator-promise">Promise</a>
</li>
</ul>
</li>
<li><a href="reference.html#task">async/task.hpp</a>
<ul class="sectlevel3">
<li><a href="reference.html#executor_3">Executor</a>
</li>
<li><a href="reference.html#memory_resource_3">Memory Resource</a>
</li>
<li><a href="reference.html#task-outline">Outline</a>
</li>
<li><a href="reference.html#task-task">Promise</a>
</li>
<li><a href="reference.html#use_task">use_task</a>
</li>
</ul>
</li>
<li><a href="reference.html#detached">async/detached.hpp</a>
<ul class="sectlevel3">
<li><a href="reference.html#executor_4">Executor</a>
</li>
<li><a href="reference.html#memory_resource_4">Memory Resource</a>
</li>
<li><a href="reference.html#detached-outline">Outline</a>
</li>
<li><a href="reference.html#detached-detached">Promise</a>
</li>
</ul>
</li>
<li><a href="reference.html#async_operation">async/op.hpp</a>
<ul class="sectlevel3">
<li><a href="reference.html#use_op">use_op</a>
</li>
<li><a href="reference.html#op">Hand coded Operations</a>
</li>
</ul>
</li>
<li><a href="reference.html#concepts">async/concepts.hpp</a>
<ul class="sectlevel3">
<li><a href="reference.html#awaitable">Awaitable</a>
</li>
<li><a href="reference.html#enable_awaitables">Enable awaitables</a>
</li>
</ul>
</li>
<li><a href="reference.html#this_coro">async/this_coro.hpp</a>
<ul class="sectlevel3">
<li><a href="reference.html#enable_await_allocator">Await Allocator</a>
</li>
<li><a href="reference.html#enable_await_executor">Await Executor</a>
</li>
<li><a href="reference.html#promise_memory_resource_base">Memory resource base</a>
</li>
<li><a href="reference.html#promise_throw_if_cancelled_base">Throw if cancelled</a>
</li>
<li><a href="reference.html#promise_cancellation_base">Cancellation state</a>
</li>
</ul>
</li>
<li><a href="reference.html#this_thread">async/this_thread.hpp</a>
</li>
<li><a href="reference.html#channel">async/channel.hpp</a>
<ul class="sectlevel3">
<li><a href="reference.html#outline">Outline</a>
</li>
<li><a href="reference.html#description">Description</a>
</li>
<li><a href="reference.html#example">Example</a>
</li>
</ul>
</li>
<li><a href="reference.html#with">async/with.hpp</a>
</li>
<li><a href="reference.html#select">async/select.hpp</a>
<ul class="sectlevel3">
<li><a href="reference.html#interrupt_await">Interrupt Wait</a>
</li>
<li><a href="reference.html#left_select"><code>left_select</code></a>
</li>
<li><a href="reference.html#select-outline">Outline</a>
</li>
</ul>
</li>
<li><a href="reference.html#gather">async/gather.hpp</a>
<ul class="sectlevel3">
<li><a href="reference.html#gather-outline">Outline</a>
</li>
</ul>
</li>
<li><a href="reference.html#join">async/join.hpp</a>
<ul class="sectlevel3">
<li><a href="reference.html#join-outline">Outline</a>
</li>
</ul>
</li>
<li><a href="reference.html#wait_group">async/wait_group.hpp</a>
</li>
<li><a href="reference.html#spawn">async/spawn.hpp</a>
<ul class="sectlevel3">
<li><a href="reference.html#example_2">Example</a>
</li>
</ul>
</li>
<li><a href="reference.html#run">async/run.hpp</a>
<ul class="sectlevel3">
<li><a href="reference.html#run-outline">Outline</a>
</li>
<li><a href="reference.html#run-example">Example</a>
</li>
</ul>
</li>
<li><a href="reference.html#thread">async/thread.hpp</a>
<ul class="sectlevel3">
<li><a href="reference.html#executor_5">Executor</a>
</li>
<li><a href="reference.html#memory_resource_5">Memory Resource</a>
</li>
<li><a href="reference.html#thread-outline">Outline</a>
</li>
<li><a href="reference.html#thread-promise">Promise</a>
</li>
</ul>
</li>
<li><a href="reference.html#result">async/result.hpp</a>
</li>
<li><a href="reference.html#async_for">async/async_for.hpp</a>
</li>
<li><a href="reference.html#error">async/error.hpp</a>
</li>
<li><a href="reference.html#config">async/config.hpp</a>
<ul class="sectlevel3">
<li><a href="reference.html#executor_type">executor_type</a>
</li>
<li><a href="reference.html#pmr">pmr</a>
</li>
</ul>
</li>
<li><a href="reference.html#leaf">async/leaf.hpp</a>
</li>
</ul>
</li>
<li><a href="technical_background.html">Technical Background</a>
</li>
<li><a href="benchmarks.html">Benchmarks</a>
</li>
<li><a href="compiler_support.html">Compiler support</a>
</li>
<li><a href="acknowledgements.html">Acknowledgements</a>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="reference">Reference</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="main">async/main.hpp</h3>
<div class="paragraph">
<p>The easiest way to get started with an async application is to use the <code>co_main</code> function with the following signature:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">async</span><span class="o">::</span><span class="n">main</span> <span class="nf">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Declaring <code>co_main</code> will add a <code>main</code> function that performs all the necessary steps to run a coroutine
on an event loop.
This allows us to write a very simple asynchronous programs;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">async</span><span class="o">::</span><span class="n">main</span> <span class="nf">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">exec</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">async</span><span class="o">::</span><span class="n">this_coro</span><span class="o">::</span><span class="n">executor</span><span class="p">;</span>             <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="n">asio</span><span class="o">::</span><span class="n">steady_timer</span> <span class="n">tim</span><span class="p">{</span><span class="n">exec</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">50</span><span class="p">)};</span> <i class="conum" data-value="2"></i><b>(2)</b>
  <span class="k">co_await</span> <span class="n">tim</span><span class="p">.</span><span class="n">async_wait</span><span class="p">(</span><span class="n">async</span><span class="o">::</span><span class="n">use_op</span><span class="p">);</span>                      <i class="conum" data-value="3"></i><b>(3)</b>
  <span class="k">co_return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>get the executor <code>main</code> running on</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Use it with an asio object</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>co_await</code> an async operation</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The main promise will create an <code>asio::signal_set</code> and uses it for cancellation.
<code>SIGINT</code> becomes total , while <code>SIGTERM</code> becomes terminal cancellation.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The cancellation will not be forwarded to detached coroutines.
The user will need to take care to end then on cancellation,
since the program otherwise doesn&#8217;t allow graceful termination.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="executor">Executor</h4>
<div id="main-executor" class="paragraph">
<p>It will also create an <code>asio::io_context</code> to run on, which you can get through the <code>this_coro::executor</code>.
It will be assigned to the <code>async::this_thread::get_executor()</code> .</p>
</div>
</div>
<div class="sect3">
<h4 id="memory_resource">Memory Resource</h4>
<div id="main-allocator" class="paragraph">
<p>It also creates a memory resource that will be used as a default for internal memory allocations.
It will be assigned to the <code>thread_local</code> to the  <code>async::this_thread::get_default_resoruce()</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="main-promise">Promise</h4>
<div class="paragraph">
<p>Every coroutine has an internal state, called <code>promise</code> (not to be confused with the <code>async::promise</code>).
Depending on the coroutine properties different things can be <code>co_await</code>-ed, like we used in the example above.</p>
</div>
<div class="paragraph">
<p>They are implemented through inheritance, and shared among different promise types</p>
</div>
<div class="paragraph">
<p>The main promise has the following properties.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="reference.html#promise_cancellation_base">Cancellation state</a></p>
</li>
<li>
<p><a href="reference.html#promise_throw_if_cancelled_base">Throw if cancelled</a></p>
</li>
<li>
<p><a href="reference.html#enable_awaitables">Enable awaitables</a></p>
</li>
<li>
<p><a href="reference.html#enable_await_allocator">Await Allocator</a></p>
</li>
<li>
<p><a href="reference.html#enable_await_executor">Await Executor</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="specification">Specification</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>declaring <code>co_main</code> will implicitly declare a <code>main</code> function</p>
</li>
<li>
<p><code>main</code> is only present when <code>co_main</code> is defined.</p>
</li>
<li>
<p><code>SIGINT</code> and <code>SIGTERM</code> will cause cancellation of the internal task.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="promise">async/promise.hpp</h3>
<div class="paragraph">
<p>A promise is an eager coroutine that can <code>co_await</code> and <code>co_return</code> values. That is, it cannot use <code>co_yield</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">async</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">delay</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span> <span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">asio</span><span class="o">::</span><span class="n">steady_timer</span> <span class="n">tim</span><span class="p">{</span><span class="k">co_await</span> <span class="n">async</span><span class="o">::</span><span class="n">this_coro</span><span class="o">::</span><span class="n">executor</span><span class="p">,</span> <span class="n">ms</span><span class="p">};</span>
  <span class="k">co_await</span> <span class="n">tim</span><span class="p">.</span><span class="n">async_wait</span><span class="p">(</span><span class="n">async</span><span class="o">::</span><span class="n">use_op</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">async</span><span class="o">::</span><span class="n">main</span> <span class="n">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="k">co_await</span> <span class="n">delay</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">50</span><span class="p">));</span>
  <span class="k">co_return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Promises are by default attached.
This means, that a cancellation is sent when the <code>promise</code> handles goes out of scope.</p>
</div>
<div class="paragraph">
<p>A promise can be detached by calling <code>detach</code> or by using the prefix <code>+</code> operator.
This is a runtime alternative to using <a href="reference.html#detached">detached</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">async</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">my_task</span><span class="p">();</span>

<span class="n">async</span><span class="o">::</span><span class="n">main</span> <span class="nf">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="o">+</span><span class="n">my_task</span><span class="p">();</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="k">co_await</span> <span class="n">delay</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">50</span><span class="p">));</span>
  <span class="k">co_return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>By using <code>+</code> the task gets detached. Without it, the compiler would generate a <code>nodiscard</code> warning.</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="executor_2">Executor</h4>
<div id="promise-executor" class="paragraph">
<p>The executor is taken from the <code>thread_local</code> <a href="reference.html#this_thread">get_executor</a> function, unless a <code>asio::executor_arg</code> is used
in any position followed by the executor argument.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">async</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">my_gen</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">executor_arg_t</span><span class="p">,</span> <span class="n">asio</span><span class="o">::</span><span class="n">io_context</span><span class="o">::</span><span class="n">executor_type</span> <span class="n">exec_to_use</span><span class="p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="memory_resource_2">Memory Resource</h4>
<div id="promise-allocator" class="paragraph">
<p>The memory resource is taken from the <code>thread_local</code> <a href="reference.html#this_thread">get_default_resource</a> function,
unless a <code>std::allocator_arg</code> is used in any position followed by a <code>polymorphic_allocator</code> argument.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">async</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">my_gen</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">allocator_arg_t</span><span class="p">,</span> <span class="n">pmr</span><span class="o">::</span><span class="n">polymorphic_allocator</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">alloc</span><span class="p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="promise-outline">Outline</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Return</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="n">promise</span>
<span class="p">{</span>
    <span class="n">promise</span><span class="p">(</span><span class="n">promise</span> <span class="o">&amp;&amp;</span><span class="n">lhs</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="n">promise</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">promise</span> <span class="o">&amp;&amp;</span> <span class="n">lhs</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="c1">// enable `co_await`. </span><i class="conum" data-value="1"></i><b>(1)</b>
    <span class="k">auto</span> <span class="k">operator</span> <span class="k">co_await</span> <span class="p">();</span>

    <span class="c1">// Ignore the return value, i.e. detach it. </span><i class="conum" data-value="2"></i><b>(2)</b>
    <span class="kt">void</span> <span class="k">operator</span> <span class="o">+</span><span class="p">()</span> <span class="o">&amp;&amp;</span><span class="p">;</span>

    <span class="c1">// Cancel the promise.</span>
    <span class="kt">void</span> <span class="n">cancel</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span> <span class="n">ct</span> <span class="o">=</span> <span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span><span class="o">::</span><span class="n">all</span><span class="p">);</span>

    <span class="c1">// Check if the result is ready</span>
    <span class="kt">bool</span> <span class="n">ready</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">// Check if the promise can be awaited.</span>
    <span class="k">explicit</span> <span class="k">operator</span> <span class="kt">bool</span> <span class="p">()</span> <span class="k">const</span><span class="p">;</span> <i class="conum" data-value="3"></i><b>(3)</b>

    <span class="c1">// Detach or attach</span>
    <span class="kt">bool</span> <span class="n">attached</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">detach</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">attach</span><span class="p">();</span>
    <span class="c1">// Get the return value if ready - otherwise throw</span>
    <span class="n">Return</span> <span class="n">get</span><span class="p">();</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Supports <a href="reference.html#interrupt_await">Interrupt Wait</a></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This allows to spawn promised with a simple <code>+my_task()</code> expression.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>This allows code like <code>while (p) co_await p;</code></td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="promise-promise">Promise</h4>
<div class="paragraph">
<p>The coroutine promise (<code>promise::promise_type</code>) has the following properties.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="reference.html#promise_memory_resource_base">Memory resource base</a></p>
</li>
<li>
<p><a href="reference.html#promise_cancellation_base">Cancellation state</a></p>
</li>
<li>
<p><a href="reference.html#promise_throw_if_cancelled_base">Throw if cancelled</a></p>
</li>
<li>
<p><a href="reference.html#enable_awaitables">Enable awaitables</a></p>
</li>
<li>
<p><a href="reference.html#enable_await_allocator">Await Allocator</a></p>
</li>
<li>
<p><a href="reference.html#enable_await_executor">Await Executor</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="generator">async/generator.hpp</h3>
<div class="paragraph">
<p>A generator is an eager coroutine that can <code>co_await</code> and <code>co_yield</code> values to the caller.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">async</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">example</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"In coro 1</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="k">co_yield</span> <span class="mi">2</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"In coro 3</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="k">co_return</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">async</span><span class="o">::</span><span class="n">main</span> <span class="n">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"In main 0</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">example</span><span class="p">();</span> <span class="c1">// call and let it run until the first co_yield</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"In main 1</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"In main %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">co_await</span> <span class="n">f</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"In main %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">co_await</span> <span class="n">f</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Which will generate the following output</p>
</div>
<div class="literalblock">
<div class="content">
<pre>In main 0
In coro 1
In main 1
In main 2
In coro 3
In main 4</pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="diag-7d35836ce40d736190db3f748f30383d.png" alt="Diagram" width="650" height="583">
</div>
</div>
<div class="paragraph">
<p>Values can be pushed into the generator, when <code>Push</code> (the second template parameter) is set to non-void:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">async</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">example</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"In coro 1</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span>  <span class="k">co_yield</span> <span class="mi">2</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"In coro %d</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="k">co_return</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">async</span><span class="o">::</span><span class="n">main</span> <span class="n">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"In main 0</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">example</span><span class="p">();</span> <span class="c1">// call and let it run until the first co_yield</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"In main %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">co_await</span> <span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The pushed value gets passed through <code>operator()</code> to the result of <code>co_yield</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Which will generate the following output</p>
</div>
<div class="literalblock">
<div class="content">
<pre>In main 0
In coro 1
In main 2
Pushed 2
In coro 3
In main 4</pre>
</div>
</div>
<div class="sect3">
<h4 id="initial">Lazy</h4>
<div class="paragraph">
<p>A generator can be turned lazy by awaiting initial.
This <code>co_await</code> expression will produce the <code>Push</code> value.
This means the generator will wait until it&#8217;s awaited for the first time,
and then process the newly pushed value and resume at the next co_yield.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">async</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">example</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">async</span><span class="o">::</span><span class="n">this_coro</span><span class="o">::</span><span class="n">initial</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"In coro %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
  <span class="k">co_yield</span> <span class="mi">2</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"In coro %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
  <span class="k">co_return</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">async</span><span class="o">::</span><span class="n">main</span> <span class="n">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"In main 0</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">example</span><span class="p">();</span> <span class="c1">// call and let it run until the first co_yield</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"In main 1</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span> <span class="c1">// &lt; this is now before the co_await initial</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"In main %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">co_await</span> <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"In main %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">co_await</span> <span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Which will generate the following output</p>
</div>
<div class="literalblock">
<div class="content">
<pre>In main 0
In main 1
In coro 1
In main 2
In coro 3
In main 4</pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="diag-7d35836ce40d736190db3f748f30383d.png" alt="Diagram" width="650" height="583">
</div>
</div>
</div>
<div class="sect3">
<h4 id="generator-executor">Executor</h4>
<div class="paragraph">
<p>The executor is taken from the <code>thread_local</code> <a href="reference.html#this_thread">get_executor</a> function, unless a <code>asio::executor_arg</code> is used
in any position followed by the executor argument.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">async</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">my_gen</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">executor_arg_t</span><span class="p">,</span> <span class="n">asio</span><span class="o">::</span><span class="n">io_context</span><span class="o">::</span><span class="n">executor_type</span> <span class="n">exec_to_use</span><span class="p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="generator-allocator">Memory Resource</h4>
<div class="paragraph">
<p>The memory resource is taken from the <code>thread_local</code> <a href="reference.html#this_thread">get_default_resource</a> function,
unless a <code>std::allocator_arg</code> is used in any position followed by a <code>polymorphic_allocator</code> argument.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">async</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">my_gen</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">allocator_arg_t</span><span class="p">,</span> <span class="n">pmr</span><span class="o">::</span><span class="n">polymorphic_allocator</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">alloc</span><span class="p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="generator-outline">Outline</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Yield</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Push</span> <span class="o">=</span> <span class="kt">void</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="n">generator</span>
<span class="p">{</span>
  <span class="c1">// Movable</span>

  <span class="n">generator</span><span class="p">(</span><span class="n">generator</span> <span class="o">&amp;&amp;</span><span class="n">lhs</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="n">generator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">generator</span> <span class="o">&amp;&amp;</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

  <span class="c1">// True until it co_returns &amp; is co_awaited after </span><i class="conum" data-value="1"></i><b>(1)</b>
  <span class="k">explicit</span> <span class="k">operator</span> <span class="kt">bool</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// Cancel the generator. </span><i class="conum" data-value="3"></i><b>(3)</b>
  <span class="kt">void</span> <span class="n">cancel</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span> <span class="n">ct</span> <span class="o">=</span> <span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span><span class="o">::</span><span class="n">all</span><span class="p">);</span>

  <span class="c1">// Check if a value is available</span>
  <span class="kt">bool</span> <span class="n">ready</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// Get the return value. Throws if not <code>ready</code>.</span>
  <span class="n">Yield</span> <span class="n">get</span><span class="p">();</span>

  <span class="c1">// Cancel &amp; detach the generator.</span>
  <span class="o">~</span><span class="n">generator</span><span class="p">();</span>

  <span class="c1">// an awaitable that results in value of <code>Yield</code>.</span>
  <span class="k">using</span> <span class="n"><em>generator_awaitable</em></span> <span class="o">=</span> <span class="n"><em>unspecified</em></span><span class="p">;</span>

  <span class="c1">// Present when <code>Push</code> != <code>void</code></span>
  <span class="n"><em>generator_awaitable</em></span> <span class="k">operator</span><span class="p">()(</span>      <span class="n">Push</span> <span class="o">&amp;&amp;</span> <span class="n">push</span><span class="p">);</span>
  <span class="n"><em>generator_awaitable</em></span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Push</span> <span class="o">&amp;</span>  <span class="n">push</span><span class="p">);</span>

  <span class="c1">// Present when <code>Push</code> == <code>void</code>, i.e. can <code>co_await</code> the generator directly.</span>
  <span class="n"><em>generator_awaitable</em></span> <span class="k">operator</span> <span class="k">co_await</span> <span class="p">();</span> <i class="conum" data-value="2"></i><b>(2)</b>

<span class="p">};</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This allows code like <code>while (gen) co_await gen:</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Supports <a href="reference.html#interrupt_await">Interrupt Wait</a></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>A cancelled generator maybe be resumable</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="generator-promise">Promise</h4>
<div class="paragraph">
<p>The generator promise has the following properties.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="reference.html#promise_memory_resource_base">Memory resource base</a></p>
</li>
<li>
<p><a href="reference.html#promise_cancellation_base">Cancellation state</a></p>
</li>
<li>
<p><a href="reference.html#promise_throw_if_cancelled_base">Throw if cancelled</a></p>
</li>
<li>
<p><a href="reference.html#enable_awaitables">Enable awaitables</a></p>
</li>
<li>
<p><a href="reference.html#enable_await_allocator">Await Allocator</a></p>
</li>
<li>
<p><a href="reference.html#enable_await_executor">Await Executor</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="task">async/task.hpp</h3>
<div class="paragraph">
<p>A task is a lazy coroutine that can <code>co_await</code> and <code>co_return</code> values. That is, it cannot use <code>co_yield</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">async</span><span class="o">::</span><span class="n">task</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">delay</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span> <span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">asio</span><span class="o">::</span><span class="n">steady_timer</span> <span class="n">tim</span><span class="p">{</span><span class="k">co_await</span> <span class="n">async</span><span class="o">::</span><span class="n">this_coro</span><span class="o">::</span><span class="n">executor</span><span class="p">,</span> <span class="n">ms</span><span class="p">};</span>
  <span class="k">co_await</span> <span class="n">tim</span><span class="p">.</span><span class="n">async_wait</span><span class="p">(</span><span class="n">async</span><span class="o">::</span><span class="n">use_op</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">async</span><span class="o">::</span><span class="n">main</span> <span class="n">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="k">co_await</span> <span class="n">delay</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">50</span><span class="p">));</span>
  <span class="k">co_return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Unlike a <a href="reference.html#promise">promise</a>, a task can be awaited or spawned on another executor than it was created on.</p>
</div>
<div class="sect3">
<h4 id="executor_3">Executor</h4>
<div id="task-executor" class="paragraph">
<p>Since a <code>task</code> it lazy, it does not need to have an executor on construction.
It rather attempts to take it from the caller or awaiter if present.
Otherwise, it&#8217;ll default to the thread_local executor.</p>
</div>
</div>
<div class="sect3">
<h4 id="memory_resource_3">Memory Resource</h4>
<div id="task-allocator" class="paragraph">
<p>The memory resource is <strong>NOT</strong> taken from the <code>thread_local</code> <a href="reference.html#this_thread">get_default_resource</a> function,
but <code>pmr::get_default_resource(),
unless a `std::allocator_arg</code> is used in any position followed by a <code>polymorphic_allocator</code> argument.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">async</span><span class="o">::</span><span class="n">task</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">my_gen</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">allocator_arg_t</span><span class="p">,</span> <span class="n">pmr</span><span class="o">::</span><span class="n">polymorphic_allocator</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">alloc</span><span class="p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="task-outline">Outline</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Return</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="n">task</span>
<span class="p">{</span>
    <span class="n">task</span><span class="p">(</span><span class="n">task</span> <span class="o">&amp;&amp;</span><span class="n">lhs</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">task</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">task</span> <span class="o">&amp;&amp;</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="c1">// enable `co_await`</span>
    <span class="k">auto</span> <span class="k">operator</span> <span class="k">co_await</span> <span class="p">();</span>

<span class="p">};</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Tasks can be used synchronously from a sync function by calling <code>run(my_task())</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="task-task">Promise</h4>
<div class="paragraph">
<p>The task promise has the following properties.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="reference.html#promise_memory_resource_base">Memory resource base</a></p>
</li>
<li>
<p><a href="reference.html#promise_cancellation_base">Cancellation state</a></p>
</li>
<li>
<p><a href="reference.html#promise_throw_if_cancelled_base">Throw if cancelled</a></p>
</li>
<li>
<p><a href="reference.html#enable_awaitables">Enable awaitables</a></p>
</li>
<li>
<p><a href="reference.html#enable_await_allocator">Await Allocator</a></p>
</li>
<li>
<p><a href="reference.html#enable_await_executor">Await Executor</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="use_task">use_task</h4>
<div class="paragraph">
<p>The <code>use_task</code> completion token can be used to create a task from an <code>async_</code> function.
This is less efficient than <a href="reference.html#use_op">use_op</a> as it needs to allocate a coroutine frame,
but has a simpler return type and supports <a href="reference.html#interrupt_await">Interrupt Wait</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="detached">async/detached.hpp</h3>
<div class="paragraph">
<p>A detached is an eager coroutine that can <code>co_await</code> but not <code>co_return</code> values.
That is, it cannot be resumed and is usually not awaited.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">async</span><span class="o">::</span><span class="n">detached</span> <span class="nf">delayed_print</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span> <span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">asio</span><span class="o">::</span><span class="n">steady_timer</span> <span class="n">tim</span><span class="p">{</span><span class="k">co_await</span> <span class="n">async</span><span class="o">::</span><span class="n">this_coro</span><span class="o">::</span><span class="n">executor</span><span class="p">,</span> <span class="n">ms</span><span class="p">};</span>
  <span class="k">co_await</span> <span class="n">tim</span><span class="p">.</span><span class="n">async_wait</span><span class="p">(</span><span class="n">async</span><span class="o">::</span><span class="n">use_op</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Hello world</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">async</span><span class="o">::</span><span class="n">main</span> <span class="n">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="n">delayed_print</span><span class="p">();</span>
  <span class="k">co_return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Detached is used to run coroutines in the background easily.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">async</span><span class="o">::</span><span class="n">detached</span> <span class="nf">my_task</span><span class="p">();</span>

<span class="n">async</span><span class="o">::</span><span class="n">main</span> <span class="nf">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="n">my_task</span><span class="p">();</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="k">co_await</span> <span class="n">delay</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">50</span><span class="p">));</span>
  <span class="k">co_return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Spawn off the detached coro.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A detached can assign itself a new cancellation source like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">async</span><span class="o">::</span><span class="n">detached</span> <span class="nf">my_task</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">cancellation_slot</span> <span class="n">sl</span><span class="p">)</span>
<span class="p">{</span>
   <span class="k">co_await</span> <span class="n">this_coro</span><span class="o">::</span><span class="n">reset_cancellation_source</span><span class="p">(</span><span class="n">sl</span><span class="p">);</span>
   <span class="c1">// do somework</span>
<span class="p">}</span>

<span class="n">async</span><span class="o">::</span><span class="n">main</span> <span class="n">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="n">asio</span><span class="o">::</span><span class="n">cancellation_signal</span> <span class="n">sig</span><span class="p">;</span>
  <span class="n">my_task</span><span class="p">(</span><span class="n">sig</span><span class="p">.</span><span class="n">slot</span><span class="p">());</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="k">co_await</span> <span class="n">delay</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">50</span><span class="p">));</span>
  <span class="n">sig</span><span class="p">.</span><span class="n">emit</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span><span class="o">::</span><span class="n">all</span><span class="p">);</span>
  <span class="k">co_return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="executor_4">Executor</h4>
<div id="detached-executor" class="paragraph">
<p>The executor is taken from the <code>thread_local</code> <a href="reference.html#this_thread">get_executor</a> function, unless a <code>asio::executor_arg</code> is used
in any position followed by the executor argument.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">async</span><span class="o">::</span><span class="n">detached</span> <span class="nf">my_gen</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">executor_arg_t</span><span class="p">,</span> <span class="n">asio</span><span class="o">::</span><span class="n">io_context</span><span class="o">::</span><span class="n">executor_type</span> <span class="n">exec_to_use</span><span class="p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="memory_resource_4">Memory Resource</h4>
<div id="detached-allocator" class="paragraph">
<p>The memory resource is taken from the <code>thread_local</code> <a href="reference.html#this_thread">get_default_resource</a> function,
unless a <code>std::allocator_arg</code> is used in any position followed by a <code>polymorphic_allocator</code> argument.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">async</span><span class="o">::</span><span class="n">detached</span> <span class="nf">my_gen</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">allocator_arg_t</span><span class="p">,</span> <span class="n">pmr</span><span class="o">::</span><span class="n">polymorphic_allocator</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">alloc</span><span class="p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="detached-outline">Outline</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">struct</span> <span class="nc">detached</span> <span class="p">{};</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Supports <a href="reference.html#interrupt_await">Interrupt Wait</a></td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="detached-detached">Promise</h4>
<div class="paragraph">
<p>The thread detached has the following properties.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="reference.html#promise_memory_resource_base">Memory resource base</a></p>
</li>
<li>
<p><a href="reference.html#promise_cancellation_base">Cancellation state</a></p>
</li>
<li>
<p><a href="reference.html#promise_throw_if_cancelled_base">Throw if cancelled</a></p>
</li>
<li>
<p><a href="reference.html#enable_awaitables">Enable awaitables</a></p>
</li>
<li>
<p><a href="reference.html#enable_await_allocator">Await Allocator</a></p>
</li>
<li>
<p><a href="reference.html#enable_await_executor">Await Executor</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="async_operation">async/op.hpp</h3>
<div class="paragraph">
<p>An async operation is an <a href="reference.html#awaitable">awaitable</a> wrapping an <code>asio</code> operation.</p>
</div>
<div class="paragraph">
<p>E.g. this is an <code>async_operation</code> with the completion signature  <code>void()</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">auto</span> <span class="n">op</span> <span class="o">=</span> <span class="n">asio</span><span class="o">::</span><span class="n">post</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">async</span><span class="o">::</span><span class="n">use_op</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Or the async_operation can be templated like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">auto</span> <span class="n">op</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">](</span><span class="k">auto</span> <span class="n">token</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">asio</span><span class="o">::</span><span class="n">post</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">token</span><span class="p">));</span> <span class="p">};</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="use_op">use_op</h4>
<div class="paragraph">
<p>The <code>use_op</code> token is the direct to create an op,
i.e. using <code>async::use_op</code> as the completion token will create the required awaitable.</p>
</div>
<div class="paragraph">
<p>It also supports <code>defaults_on</code> so that async_ops can be awaited without the token:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">auto</span> <span class="n">tim</span> <span class="o">=</span> <span class="n">async</span><span class="o">::</span><span class="n">use_op</span><span class="p">.</span><span class="n">as_default_on</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">steady_timer</span><span class="p">{</span><span class="k">co_await</span> <span class="n">async</span><span class="o">::</span><span class="n">this_coro</span><span class="o">::</span><span class="n">executor</span><span class="p">});</span>
<span class="k">co_await</span> <span class="n">tim</span><span class="p">.</span><span class="n">async_wait</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Depending on the completion signature the <code>co_await</code> expression may throw.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Signature</th>
<th class="tableblock halign-left valign-top">Return type</th>
<th class="tableblock halign-left valign-top">Exception</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>noexcept</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void(T)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>T</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>noexcept</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void(T&#8230;&#8203;)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>std::tuple&lt;T&#8230;&#8203;&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>noexcept</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void(system::error_code, T)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>T</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>system::system_error</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void(system::error_code, T&#8230;&#8203;)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>std::tuple&lt;T&#8230;&#8203;&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>system::system_error</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void(std::exception_ptr, T)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>T</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>any exception</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void(std::exception_ptr, T&#8230;&#8203;)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>std::tuple&lt;T&#8230;&#8203;&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>any exception</em></p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>use_op</code> will never complete immediately, i.e. <code>await_ready</code> will always return false, but always suspend the coroutine.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="op">Hand coded Operations</h4>
<div class="paragraph">
<p>Operations are a more advanced implementation of the <a href="reference.html#async_operation">async/op.hpp</a> feature.</p>
</div>
<div class="paragraph">
<p>This library makes it easy to create asynchronous operations with an early completion condition,
i.e. a condition that avoids suspension of coroutines altogether.</p>
</div>
<div class="paragraph">
<p>We can for example create a <code>wait_op</code> that does nothing if the timer is already expired.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">struct</span> <span class="nc">wait_op</span> <span class="o">:</span> <span class="n">async</span><span class="o">::</span><span class="n">op</span><span class="o">&lt;</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="o">&gt;</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="p">{</span>
  <span class="n">asio</span><span class="o">::</span><span class="n">steady_timer</span> <span class="o">&amp;</span> <span class="n">tim</span><span class="p">;</span>

  <span class="n">wait_op</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">steady_timer</span> <span class="o">&amp;</span> <span class="n">tim</span><span class="p">)</span> <span class="o">:</span> <span class="n">tim</span><span class="p">(</span><span class="n">tim</span><span class="p">)</span> <span class="p">{}</span>

  <span class="kt">bool</span> <span class="n">ready</span><span class="p">(</span><span class="n">async</span><span class="o">::</span><span class="n">handler</span><span class="o">&lt;</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="o">&gt;</span> <span class="p">)</span> <i class="conum" data-value="2"></i><b>(2)</b>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tim</span><span class="p">.</span><span class="n">expiry</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">now</span><span class="p">())</span>
        <span class="n">h</span><span class="p">(</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="p">{});</span>
  <span class="p">}</span>
  <span class="kt">void</span> <span class="n">initiate</span><span class="p">(</span><span class="n">async</span><span class="o">::</span><span class="n">completion_handler</span><span class="o">&lt;</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="o">&gt;</span> <span class="n">complete</span><span class="p">)</span> <i class="conum" data-value="3"></i><b>(3)</b>
  <span class="p">{</span>
    <span class="n">tim</span><span class="p">.</span><span class="n">async_wait</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">complete</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Inherit <code>op</code> with the matching signature <code>await_transform</code> picks it up</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Check if the operation is ready - called from <code>await_ready</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Initiate the async operation if its not ready.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="concepts">async/concepts.hpp</h3>
<div class="sect3">
<h4 id="awaitable">Awaitable</h4>
<div class="paragraph">
<p>An awaitable is an expression that can be used with <code>co_await</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Awaitable</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Promise</span> <span class="o">=</span> <span class="kt">void</span><span class="p">&gt;</span>
<span class="k">concept</span> <span class="n">awaitable_type</span> <span class="o">=</span> <span class="k">requires</span> <span class="p">(</span><span class="n">Awaitable</span> <span class="n">aw</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">Promise</span><span class="o">&gt;</span> <span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">{</span><span class="n">aw</span><span class="p">.</span><span class="n">await_ready</span><span class="p">()}</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">convertible_to</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="p">{</span><span class="n">aw</span><span class="p">.</span><span class="n">await_suspend</span><span class="p">(</span><span class="n">h</span><span class="p">)};</span>
    <span class="p">{</span><span class="n">aw</span><span class="p">.</span><span class="n">await_resume</span><span class="p">()};</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Awaitable</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Promise</span> <span class="o">=</span> <span class="kt">void</span><span class="p">&gt;</span>
<span class="k">concept</span> <span class="n">awaitable</span> <span class="o">=</span>
        <span class="n">awaitable_type</span><span class="o">&lt;</span><span class="n">Awaitable</span><span class="p">,</span> <span class="n">Promise</span><span class="o">&gt;</span>
    <span class="o">||</span> <span class="k">requires</span> <span class="p">(</span><span class="n">Awaitable</span> <span class="o">&amp;&amp;</span> <span class="n">aw</span><span class="p">)</span> <span class="p">{</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Awaitable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">aw</span><span class="p">).</span><span class="k">operator</span> <span class="k">co_await</span><span class="p">()}</span> <span class="o">-&gt;</span> <span class="n">awaitable_type</span><span class="o">&lt;</span><span class="n">Promise</span><span class="o">&gt;</span><span class="p">;}</span>
    <span class="o">||</span> <span class="k">requires</span> <span class="p">(</span><span class="n">Awaitable</span> <span class="o">&amp;&amp;</span> <span class="n">aw</span><span class="p">)</span> <span class="p">{</span> <span class="p">{</span><span class="k">operator</span> <span class="k">co_await</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Awaitable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">aw</span><span class="p">))}</span> <span class="o">-&gt;</span> <span class="n">awaitable_type</span><span class="o">&lt;</span><span class="n">Promise</span><span class="o">&gt;</span><span class="p">;};</span></code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<a href="reference.html#awaitable">awaitables</a> in this library require that the coroutine promise
return their executor by const reference if they provide one. Otherwise it&#8217;ll use <code>this_thread::get_executor()</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="enable_awaitables">Enable awaitables</h4>
<div class="paragraph">
<p>Inheriting <code>enable_awaitables</code> will enable a coroutine to co_await anything through <code>await_transform</code>
that would be <code>co_await</code>-able in the absence of any <code>await_transform</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="this_coro">async/this_coro.hpp</h3>
<div class="paragraph">
<p>The <code>this_coro</code> namespace provides utilities to access the internal state of a coroutine promise.</p>
</div>
<div class="paragraph">
<p>Pseudo-awaitables:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// Awaitable type that returns the executor of the current coroutine.</span>
<span class="k">struct</span> <span class="nc">executor_t</span> <span class="p">{}</span>
<span class="k">constexpr</span> <span class="n">executor_t</span> <span class="n">executor</span><span class="p">;</span>

<span class="c1">// Awaitable type that returns the cancellation state of the current coroutine.</span>
<span class="k">struct</span> <span class="nc">cancellation_state_t</span> <span class="p">{};</span>
<span class="k">constexpr</span> <span class="n">cancellation_state_t</span> <span class="n">cancellation_state</span><span class="p">;</span>

<span class="c1">// Reset the cancellation state with custom or default filters.</span>
<span class="k">constexpr</span> <span class="n"><em>unspecified</em></span> <span class="n">reset_cancellation_state</span><span class="p">();</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Filter</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="n"><em>unspecified</em></span> <span class="n">reset_cancellation_state</span><span class="p">(</span>
    <span class="n">Filter</span> <span class="o">&amp;&amp;</span> <span class="n">filter</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">InFilter</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">OutFilter</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="n"><em>unspecified</em></span> <span class="n">reset_cancellation_state</span><span class="p">(</span>
    <span class="n">InFilter</span> <span class="o">&amp;&amp;</span> <span class="n">in_filter</span><span class="p">,</span>
    <span class="n">OutFilter</span> <span class="o">&amp;&amp;</span> <span class="n">out_filter</span><span class="p">);</span>

<span class="c1">// get &amp; set the throw_if_cancelled setting.</span>
<span class="n"><em>unspecified</em></span> <span class="n">throw_if_cancelled</span><span class="p">();</span>
<span class="n"><em>unspecified</em></span> <span class="n">throw_if_cancelled</span><span class="p">(</span><span class="kt">bool</span> <span class="n">value</span><span class="p">);</span>

<span class="c1">// Set the cancellation source in a detached.</span>
<span class="n"><em>unspecified</em></span> <span class="n">reset_cancellation_source</span><span class="p">();</span>
<span class="n"><em>unspecified</em></span> <span class="n">reset_cancellation_source</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">cancellation_slot</span> <span class="n">slot</span><span class="p">);</span>


<span class="c1">// get the allocator the promise</span>
<span class="k">struct</span> <span class="nc">allocator_t</span> <span class="p">{};</span>
<span class="k">constexpr</span> <span class="n">allocator_t</span> <span class="n">allocator</span><span class="p">;</span>

<span class="c1">// get the current cancellation state-type</span>
<span class="k">struct</span> <span class="nc">cancelled_t</span> <span class="p">{};</span>
<span class="k">constexpr</span> <span class="n">cancelled_t</span> <span class="n">cancelled</span><span class="p">;</span>

<span class="c1">// set the over-eager mode of a generator</span>
<span class="k">struct</span> <span class="nc">initial_t</span> <span class="p">{};</span>
<span class="k">constexpr</span> <span class="n">initial_t</span> <span class="n">initial</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="enable_await_allocator">Await Allocator</h4>
<div class="paragraph">
<p>The allocator of a coroutine supporting <code>enable_await_allocator</code> can be obtained the following way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">co_await</span> <span class="n">async</span><span class="o">::</span><span class="n">this_coro</span><span class="o">::</span><span class="n">allocator</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In order to enable this for your own coroutine you can inherit <code>enable_await_allocator</code> with the CRTP pattern:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">struct</span> <span class="nc">my_promise</span> <span class="o">:</span> <span class="n">async</span><span class="o">::</span><span class="n">enable_await_allocator</span><span class="o">&lt;</span><span class="n">my_promise</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="k">using</span> <span class="n">allocator_type</span> <span class="o">=</span> <span class="n">__your_allocator_type__</span><span class="p">;</span>
  <span class="n">allocator_type</span> <span class="n">get_allocator</span><span class="p">();</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If available the allocator gets used by <a href="reference.html#use_op">use_op</a>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="enable_await_executor">Await Executor</h4>
<div class="paragraph">
<p>The allocator of a coroutine supporting <code>enable_await_executor</code> can be obtained the following way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">co_await</span> <span class="n">async</span><span class="o">::</span><span class="n">this_coro</span><span class="o">::</span><span class="n">executor</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In order to enable this for your own coroutine you can inherit <code>enable_await_executor</code> with the CRTP pattern:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">struct</span> <span class="nc">my_promise</span> <span class="o">:</span> <span class="n">async</span><span class="o">::</span><span class="n">enable_await_executor</span><span class="o">&lt;</span><span class="n">my_promise</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="k">using</span> <span class="n">executor_type</span> <span class="o">=</span> <span class="n">__your_executor_type__</span><span class="p">;</span>
  <span class="n">executor_type</span> <span class="n">get_executor</span><span class="p">();</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If available the executor gets used by <a href="reference.html#use_op">use_op</a>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="promise_memory_resource_base">Memory resource base</h4>
<div class="paragraph">
<p>The <code>promise_memory_resource_base</code> base of a promise will provide a <code>get_allocator</code> in the promise taken from
either the default resource or one passed following a <code>std::allocator_arg</code> argument.
Likewise, it will add <code>operator new</code> overloads so the coroutine uses the same memory resource for its frame allocation.</p>
</div>
</div>
<div class="sect3">
<h4 id="promise_throw_if_cancelled_base">Throw if cancelled</h4>
<div class="paragraph">
<p>The <code>promise_throw_if_cancelled_base</code> provides the basic options to allow operation to enable a coroutines
to turn throw an exception when another actual <a href="reference.html#awaitable">awaitable</a> is awaited.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">co_await</span> <span class="n">async</span><span class="o">::</span><span class="n">this_coro</span><span class="o">::</span><span class="n">throw_if_cancelled</span><span class="p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="promise_cancellation_base">Cancellation state</h4>
<div class="paragraph">
<p>The <code>promise_cancellation_base</code> provides the basic options to allow operation to enable a coroutines
to have a cancellation_state that is resettable by
<a href="https://www.boost.org/doc/libs/master/doc/html/boost_asio/reference/this_coro__reset_cancellation_state.html"><code>reset_cancellation_state</code></a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">co_await</span> <span class="n">async</span><span class="o">::</span><span class="n">this_coro</span><span class="o">::</span><span class="n">reset_cancellation_state</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For convenience there is also a short-cut to check the current cancellation status:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span> <span class="n">ct</span> <span class="o">=</span> <span class="p">(</span><span class="k">co_await</span> <span class="n">async</span><span class="o">::</span><span class="n">this_coro</span><span class="o">::</span><span class="n">cancellation_state</span><span class="p">).</span><span class="n">cancelled</span><span class="p">();</span>
<span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span> <span class="n">ct</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">async</span><span class="o">::</span><span class="n">this_coro</span><span class="o">::</span><span class="n">cancelled</span><span class="p">;</span> <span class="c1">// same as above</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="this_thread">async/this_thread.hpp</h3>
<div class="paragraph">
<p>Since everything is single threaded this library provides an executor
&amp; default memory-resource for every thread.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">namespace</span> <span class="n">boost</span><span class="o">::</span><span class="n">async</span><span class="o">::</span><span class="n">this_thread</span>
<span class="p">{</span>

<span class="n">pmr</span><span class="o">::</span><span class="n">memory_resource</span><span class="o">*</span> <span class="n">get_default_resource</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="n">pmr</span><span class="o">::</span><span class="n">memory_resource</span><span class="o">*</span> <span class="n">set_default_resource</span><span class="p">(</span><span class="n">pmr</span><span class="o">::</span><span class="n">memory_resource</span><span class="o">*</span> <span class="n">r</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span> <i class="conum" data-value="2"></i><b>(2)</b>
<span class="n">pmr</span><span class="o">::</span><span class="n">polymorphic_allocator</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">get_allocator</span><span class="p">();</span> <i class="conum" data-value="3"></i><b>(3)</b>

<span class="k">typename</span> <span class="n">asio</span><span class="o">::</span><span class="n">io_context</span><span class="o">::</span><span class="n">executor_type</span> <span class="o">&amp;</span> <span class="n">get_executor</span><span class="p">();</span> <i class="conum" data-value="4"></i><b>(4)</b>
<span class="kt">void</span> <span class="n">set_executor</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">io_context</span><span class="o">::</span><span class="n">executor_type</span> <span class="n">exec</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span> <i class="conum" data-value="5"></i><b>(5)</b>

<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Get the default resource - will be pmr::get_default_resource unless set</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Set the default resource - returns the previously set one</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Get an allocator wrapping (1)</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Get the executor of the thread - throws if not set</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Set the executor of the current thread.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The coroutines will use these as defaults, but keep a copy just in case.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The only exception is the initialization of an async-operation,
which will use the this_thread::executor to rethrow from.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="channel">async/channel.hpp</h3>
<div class="paragraph">
<p>Channels can be used to exchange data between different coroutines
on a single thread.</p>
</div>
<div class="sect3">
<h4 id="outline">Outline</h4>
<div class="listingblock">
<div class="title">channel outline</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">channel</span>
<span class="p">{</span>
  <span class="c1">// create a channel with a buffer limit, executor &amp; resource.</span>
  <span class="k">explicit</span>
  <span class="n">channel</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">limit</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">,</span>
          <span class="n">executor</span> <span class="n">executor</span> <span class="o">=</span> <span class="n">this_thread</span><span class="o">::</span><span class="n">get_executor</span><span class="p">(),</span>
          <span class="n">pmr</span><span class="o">::</span><span class="n">memory_resource</span> <span class="o">*</span> <span class="n">resource</span> <span class="o">=</span> <span class="n">this_thread</span><span class="o">::</span><span class="n">get_default_resource</span><span class="p">());</span>
  <span class="c1">// movable. moving with active operations is undefined behaviour.</span>
  <span class="n">channel</span><span class="p">(</span><span class="n">channel</span> <span class="o">&amp;&amp;</span> <span class="p">)</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="n">channel</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">channel</span> <span class="o">&amp;&amp;</span> <span class="n">lhs</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

  <span class="k">using</span> <span class="n">executor_type</span> <span class="o">=</span> <span class="n">executor</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">executor_type</span> <span class="o">&amp;</span> <span class="n">get_executor</span><span class="p">();</span>

  <span class="c1">// Closes the channel</span>
  <span class="o">~</span><span class="n">channel</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="n">is_open</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="c1">// close the operation, will cancel all pending ops, too</span>
  <span class="kt">void</span> <span class="n">close</span><span class="p">();</span>

  <span class="c1">// an awaitable that yields T</span>
  <span class="k">using</span> <span class="n"><em>read_op</em></span> <span class="o">=</span> <span class="n"><em>unspecified</em></span><span class="p">;</span>

  <span class="c1">// an awaitable that yields void</span>
  <span class="k">using</span> <span class="n"><em>write_op</em></span> <span class="o">=</span> <span class="n"><em>unspecified</em></span><span class="p">;</span>

  <span class="c1">// read a value to a channel</span>
  <span class="n"><em>read_op</em></span>  <span class="n">read</span><span class="p">();</span>

  <span class="c1">// write a value to the channel</span>
  <span class="n"><em>write_op</em></span> <span class="n">write</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span>  <span class="o">&amp;&amp;</span> <span class="n">value</span><span class="p">);</span>
  <span class="n"><em>write_op</em></span> <span class="n">write</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span>  <span class="o">&amp;</span>  <span class="n">value</span><span class="p">);</span>
  <span class="n"><em>write_op</em></span> <span class="n">write</span><span class="p">(</span>      <span class="n">T</span> <span class="o">&amp;&amp;</span>  <span class="n">value</span><span class="p">);</span>
  <span class="n"><em>write_op</em></span> <span class="n">write</span><span class="p">(</span>      <span class="n">T</span>  <span class="o">&amp;</span>  <span class="n">value</span><span class="p">);</span>

  <span class="c1">// write a value to the channel if T is void</span>

<span class="p">};</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="description">Description</h4>
<div class="paragraph">
<p>Channels are a tool for two coroutines to communicate and synchronize.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">buffer_size</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">channel</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ch</span><span class="p">{</span><span class="n">exec</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">};</span>

<span class="c1">// in coroutine </span><i class="conum" data-value="1"></i><b>(1)</b>
<span class="k">co_await</span> <span class="n">ch</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>

<span class="c1">// in coroutine </span><i class="conum" data-value="2"></i><b>(2)</b>
<span class="k">auto</span> <span class="n">val</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">ch</span><span class="p">.</span><span class="n">read</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Send a value to the channel - will block until it can be sent</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Read a value from the channel - will block until a value is awaitable.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Both operations maybe be blocking depending on the channel buffer size.</p>
</div>
<div class="paragraph">
<p>If the buffer size is zero, a <code>read</code> &amp; <code>write</code> will need to occur at the same time,
i.e. act as a rendezvous.</p>
</div>
<div class="paragraph">
<p>If the buffer is not full, the write operation will not suspend the coroutine;
likewise if the buffer is not empty, the read operation will not suspend.</p>
</div>
<div class="paragraph">
<p>If two operations complete at once (as is always the case with an empty buffer),
the second operation gets posted to the executor for later completion.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A channel type can be <code>void</code>, in which case <code>write</code> takes no parameter.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The channel operations can be cancelled without losing data.
This makes them usable with <a href="reference.html#select">select</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">generator</span><span class="o">&lt;</span><span class="n">variant2</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;&gt;</span> <span class="n">merge</span><span class="p">(</span>
    <span class="n">channel</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">c1</span><span class="p">,</span>
    <span class="n">channel</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">c2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">c1</span> <span class="o">&amp;&amp;</span> <span class="n">c2</span><span class="p">)</span>
       <span class="k">co_yield</span> <span class="k">co_await</span> <span class="n">select</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="example">Example</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">async</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">producer</span><span class="p">(</span><span class="n">async</span><span class="o">::</span><span class="n">channel</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">chan</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">co_await</span> <span class="n">chan</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

  <span class="n">chan</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">async</span><span class="o">::</span><span class="n">main</span> <span class="n">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="n">async</span><span class="o">::</span><span class="n">channel</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">c</span><span class="p">;</span>

  <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">producer</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">is_open</span><span class="p">())</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">co_await</span> <span class="n">c</span><span class="p">.</span><span class="n">read</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="k">co_await</span> <span class="n">p</span><span class="p">;</span>
  <span class="k">co_return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Additionally, a <code>channel_reader</code> is provided to make reading channels more convenient &amp; usable with
<a href="reference.html#async_for">BOOST_ASYNC_FOR</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">async</span><span class="o">::</span><span class="n">main</span> <span class="nf">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="n">async</span><span class="o">::</span><span class="n">channel</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">c</span><span class="p">;</span>

  <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">producer</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
  <span class="n">BOOST_ASYNC_FOR</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">,</span> <span class="n">async</span><span class="o">::</span><span class="n">channel_reader</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="k">co_await</span> <span class="n">p</span><span class="p">;</span>
  <span class="k">co_return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="with">async/with.hpp</h3>
<div class="paragraph">
<p>The <code>with</code> facility provides a way to perform asynchronous tear-down of coroutines.
That is it like an asynchronous destructor call.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">struct</span> <span class="nc">my_resource</span>
<span class="p">{</span>
  <span class="n">async</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">await_exit</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception_ptr</span> <span class="n">e</span><span class="p">);</span>
<span class="p">};</span>

<span class="n">async</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">work</span><span class="p">(</span><span class="n">my_resource</span> <span class="o">&amp;</span> <span class="n">res</span><span class="p">);</span>

<span class="n">async</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">outer</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">co_await</span> <span class="n">async</span><span class="o">::</span><span class="n">with</span><span class="p">(</span><span class="n">my_resource</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">work</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The teardown can either be done by providing an <code>await_exit</code> member function or a <code>tag_invoke</code> function
that returns an <a href="reference.html#awaitable">awaitable</a> or by providing the teardown as the third argument to <code>with</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">using</span> <span class="n">ws_stream</span> <span class="o">=</span> <span class="n">beast</span><span class="o">::</span><span class="n">websocket</span><span class="o">::</span><span class="n">stream</span><span class="o">&lt;</span><span class="n">asio</span><span class="o">::</span><span class="n">ip</span><span class="o">::</span><span class="n">tcp</span><span class="o">::</span><span class="n">socket</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="n">async</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="n">ws_stream</span><span class="o">&gt;</span> <span class="n">connect</span><span class="p">(</span><span class="n">urls</span><span class="o">::</span><span class="n">url</span><span class="p">);</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="n">async</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span>   <span class="n">disconnect</span><span class="p">(</span><span class="n">ws_stream</span> <span class="o">&amp;</span><span class="n">ws</span><span class="p">);</span> <i class="conum" data-value="2"></i><b>(2)</b>

<span class="k">auto</span> <span class="nf">teardown</span><span class="p">(</span><span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">async</span><span class="o">::</span><span class="n">with_exit_tag</span> <span class="o">&amp;</span> <span class="n">wet</span> <span class="p">,</span> <span class="n">ws_stream</span> <span class="o">&amp;</span> <span class="n">ws</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">exception_ptr</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">disconnect</span><span class="p">(</span><span class="n">ws</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">async</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">run_session</span><span class="p">(</span><span class="n">ws_stream</span> <span class="o">&amp;</span> <span class="n">ws</span><span class="p">);</span>

<span class="n">async</span><span class="o">::</span><span class="n">main</span> <span class="n">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="k">co_await</span> <span class="n">async</span><span class="o">::</span><span class="n">with</span><span class="p">(</span><span class="k">co_await</span> <span class="n">connect</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="o">&amp;</span><span class="n">run_session</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">teardown</span><span class="p">);</span>
  <span class="k">co_return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Implement websocket connect &amp; websocket initiation</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Implement an orderly shutdown.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>std::exception_ptr</code> is null if the scope is exited without exception.
NOTE: It&#8217;s legal for the <code>exit</code> functions to take the <code>exception_ptr</code> by reference and modify it.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="select">async/select.hpp</h3>
<div class="paragraph">
<p>The <code>select</code> function can be used to <code>co_await</code> one <a href="reference.html#awaitable">awaitable</a> out of a set of them.</p>
</div>
<div class="paragraph">
<p>It can be called as a variadic function with multiple <a href="reference.html#awaitable">awaitable</a> or as on a range of <a href="reference.html#awaitable">awaitables</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">async</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">task1</span><span class="p">();</span>
<span class="n">async</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">task2</span><span class="p">();</span>

<span class="n">async</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">do_wait</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">co_await</span> <span class="n">async</span><span class="o">::</span><span class="n">select</span><span class="p">(</span><span class="n">task1</span><span class="p">(),</span> <span class="n">task2</span><span class="p">());</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">async</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;&gt;</span> <span class="n">aws</span> <span class="p">{</span><span class="n">task1</span><span class="p">(),</span> <span class="n">task2</span><span class="p">()};</span>
  <span class="k">co_await</span> <span class="n">async</span><span class="o">::</span><span class="n">select</span><span class="p">(</span><span class="n">aws</span><span class="p">);</span> <i class="conum" data-value="2"></i><b>(2)</b>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Wait for a variadic set of <a href="reference.html#awaitable">awaitables</a></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>wait for a vector of <a href="reference.html#awaitable">awaitables</a></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The first parameter so <code>select</code> can be a <a href="https://en.cppreference.com/w/cpp/named_req/UniformRandomBitGenerator::">uniform random bit generator</a>.</p>
</div>
<div class="listingblock">
<div class="title">Signatures of select</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">extern</span> <span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">pv1</span><span class="p">,</span> <span class="n">pv2</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;&gt;</span> <span class="n">pvv</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">mt1337</span> <span class="n">rdm</span><span class="p">{</span><span class="mi">1</span><span class="p">};</span>
<span class="c1">// if everything returns void select returns the index</span>
<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">r1</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">select</span><span class="p">(</span><span class="n">pv1</span><span class="p">,</span> <span class="n">pv2</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">r2</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">select</span><span class="p">(</span><span class="n">rdm</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="n">pv2</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">r3</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">select</span><span class="p">(</span><span class="n">pvv</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">r4</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">select</span><span class="p">(</span><span class="n">rdm</span><span class="p">,</span> <span class="n">pvv</span><span class="p">);</span>

<span class="c1">// variant if not everything is void. void become monostate</span>
<span class="k">extern</span> <span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pi1</span><span class="p">,</span> <span class="n">pi2</span><span class="p">;</span>
<span class="n">variant2</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">monostate</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">r5</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">select</span><span class="p">(</span><span class="n">pv1</span><span class="p">,</span> <span class="n">pi1</span><span class="p">,</span> <span class="n">pi2</span><span class="p">);</span>
<span class="n">variant2</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">monostate</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">r6</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">select</span><span class="p">(</span><span class="n">rdm</span><span class="p">,</span> <span class="n">pv1</span><span class="p">,</span> <span class="n">pi1</span><span class="p">,</span> <span class="n">pi2</span><span class="p">);</span>

<span class="c1">// a range returns a pair of the index and the result if non-void</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">piv</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">r7</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">select</span><span class="p">(</span><span class="n">piv</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">r8</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">select</span><span class="p">(</span><span class="n">rdm</span><span class="p">,</span> <span class="n">piv</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="interrupt_await">Interrupt Wait</h4>
<div class="paragraph">
<p>When arguments are passed as rvalue reference, the select will attempt to use <code>.interrupt_await</code>
on the awaitable to detach the not completed <a href="reference.html#awaitable">awaitables</a>. If supported, the <a href="reference.html#awaitable">Awaitable</a> must complete immediately.
If the <code>select</code> doesn&#8217;t detect the immediate completion, it will send a cancellation.</p>
</div>
<div class="paragraph">
<p>This means that you can reuse select like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">async</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">do_wait</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">task1</span><span class="p">();</span>
  <span class="k">auto</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">task2</span><span class="p">();</span>
  <span class="k">co_await</span> <span class="n">async</span><span class="o">::</span><span class="n">select</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">);</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="k">co_await</span> <span class="n">async</span><span class="o">::</span><span class="n">select</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">);</span> <i class="conum" data-value="2"></i><b>(2)</b>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Wait for the first task to complete</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Wait for the other task to complete</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This is supported by <a href="reference.html#promise">promise</a>, <a href="reference.html#generator">generator</a> and <a href="reference.html#gather">gather</a>.</p>
</div>
<div class="paragraph">
<p>The <code>select</code> will invoke the functions of the <code>awaitable</code> as if used in a <code>co_await</code> expression
or not evaluate them at all.</p>
</div>
</div>
<div class="sect3">
<h4 id="left_select"><code>left_select</code></h4>
<div class="paragraph">
<p>The <code>left_select</code> functions are like <code>select</code> but follow a strict left-to-right scan.
This can lead to starvation issues, which is why this is not the recommended default, but can
be useful for prioritization if proper care is taken.</p>
</div>
</div>
<div class="sect3">
<h4 id="select-outline">Outline</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// Concept for the random number generator.</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">G</span><span class="p">&gt;</span>
  <span class="k">concept</span> <span class="n">uniform_random_bit_generator</span> <span class="o">=</span>
    <span class="k">requires</span> <span class="p">(</span> <span class="n">G</span> <span class="o">&amp;</span> <span class="n">g</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="p">{</span><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">decay_t</span><span class="o">&lt;</span><span class="n">G</span><span class="o">&gt;::</span><span class="n">result_type</span><span class="p">()</span> <span class="p">}</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">unsigned_integral</span><span class="p">;</span> <span class="c1">// is an unsigned integer type</span>
      <span class="c1">// T	Returns the smallest value that G's operator() may return. The value is strictly less than G::max(). The function must be constexpr.</span>
      <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">decay_t</span><span class="o">&lt;</span><span class="n">G</span><span class="o">&gt;::</span><span class="n">min</span><span class="p">()}</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">same_as</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">decay_t</span><span class="o">&lt;</span><span class="n">G</span><span class="o">&gt;::</span><span class="n">result_type</span><span class="o">&gt;</span><span class="p">;</span>
      <span class="c1">// T	Returns the largest value that G's operator() may return. The value is strictly greater than G::min(). The function must be constexpr.</span>
      <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">decay_t</span><span class="o">&lt;</span><span class="n">G</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">()}</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">same_as</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">decay_t</span><span class="o">&lt;</span><span class="n">G</span><span class="o">&gt;::</span><span class="n">result_type</span><span class="o">&gt;</span><span class="p">;</span>
      <span class="p">{</span><span class="n">g</span><span class="p">()}</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">same_as</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">decay_t</span><span class="o">&lt;</span><span class="n">G</span><span class="o">&gt;::</span><span class="n">result_type</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="p">}</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">decay_t</span><span class="o">&lt;</span><span class="n">G</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">decay_t</span><span class="o">&lt;</span><span class="n">G</span><span class="o">&gt;::</span><span class="n">min</span><span class="p">());</span>


<span class="c1">// Variadic select with a custom random number generator</span>
<span class="k">template</span><span class="o">&lt;</span><span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span> <span class="n">Ct</span> <span class="o">=</span> <span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span><span class="o">::</span><span class="n">all</span><span class="p">,</span>
         <span class="n">uniform_random_bit_generator</span> <span class="n">URBG</span><span class="p">,</span> <span class="n">awaitable</span> <span class="p">...</span> <span class="n">Promise</span><span class="p">&gt;</span>
<span class="n"><em>awaitable</em></span> <span class="n">select</span><span class="p">(</span><span class="n">URBG</span> <span class="o">&amp;&amp;</span> <span class="n">g</span><span class="p">,</span> <span class="n">Promise</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">p</span><span class="p">);</span>

<span class="c1">// Ranged select with a custom random number generator</span>
<span class="k">template</span><span class="o">&lt;</span><span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span> <span class="n">Ct</span> <span class="o">=</span> <span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span><span class="o">::</span><span class="n">all</span><span class="p">,</span>
         <span class="n">uniform_random_bit_generator</span> <span class="n">URBG</span><span class="p">,</span> <span class="n">range</span><span class="o">&lt;</span><span class="n">awaitable</span><span class="p">&gt;</span> <span class="n">PromiseRange</span><span class="o">&gt;</span>
<span class="n"><em>awaitable</em></span> <span class="n">select</span><span class="p">(</span><span class="n">URBG</span> <span class="o">&amp;&amp;</span> <span class="n">g</span><span class="p">,</span> <span class="n">PromiseRange</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="p">);</span>

<span class="c1">// Variadic select with the default random number generator</span>
<span class="k">template</span><span class="o">&lt;</span><span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span> <span class="n">Ct</span> <span class="o">=</span> <span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span><span class="o">::</span><span class="n">all</span><span class="p">,</span> <span class="n">awaitable</span><span class="p">...</span> <span class="n">Promise</span><span class="p">&gt;</span>
<span class="n"><em>awaitable</em></span> <span class="n">select</span><span class="p">(</span><span class="n">Promise</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">p</span><span class="p">);</span>

<span class="c1">// Ranged select with the default random number generator</span>
<span class="k">template</span><span class="o">&lt;</span><span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span> <span class="n">Ct</span> <span class="o">=</span> <span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span><span class="o">::</span><span class="n">all</span><span class="p">,</span> <span class="n">range</span><span class="o">&lt;</span><span class="n">awaitable</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="n"><em>awaitable</em></span> <span class="n">select</span><span class="p">(</span><span class="n">PromiseRange</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="p">);</span>

<span class="c1">// Variadic left select</span>
<span class="k">template</span><span class="o">&lt;</span><span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span> <span class="n">Ct</span> <span class="o">=</span> <span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span><span class="o">::</span><span class="n">all</span><span class="p">,</span> <span class="n">awaitable</span><span class="p">...</span> <span class="n">Promise</span><span class="p">&gt;</span>
<span class="n"><em>awaitable</em></span> <span class="n">left_select</span><span class="p">(</span><span class="n">Promise</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">p</span><span class="p">);</span>

<span class="c1">// Ranged left select</span>
<span class="k">template</span><span class="o">&lt;</span><span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span> <span class="n">Ct</span> <span class="o">=</span> <span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span><span class="o">::</span><span class="n">all</span><span class="p">,</span> <span class="n">range</span><span class="o">&lt;</span><span class="n">awaitable</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="n"><em>awaitable</em></span> <span class="n">left_select</span><span class="p">(</span><span class="n">PromiseRange</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Selecting an empty range will cause an exception to be thrown.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="gather">async/gather.hpp</h3>
<div class="paragraph">
<p>The <code>gather</code> function can be used to <code>co_await</code> multiple <a href="reference.html#awaitable">awaitables</a>
at once with cancellations being passed through.</p>
</div>
<div class="paragraph">
<p>The function will gather all completion and return them as <code>system::result</code>,
i.e. capture conceptions as values. One awaitable throwing an exception will not cancel the others.</p>
</div>
<div class="paragraph">
<p>It can be called as a variadic function with multiple <a href="reference.html#awaitable">Awaitable</a> or as on a range of <a href="reference.html#awaitable">awaitables</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">async</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">task1</span><span class="p">();</span>
<span class="n">async</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">task2</span><span class="p">();</span>

<span class="n">async</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">do_gather</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">co_await</span> <span class="n">async</span><span class="o">::</span><span class="n">gather</span><span class="p">(</span><span class="n">task1</span><span class="p">(),</span> <span class="n">task2</span><span class="p">());</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">async</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;&gt;</span> <span class="n">aws</span> <span class="p">{</span><span class="n">task1</span><span class="p">(),</span> <span class="n">task2</span><span class="p">()};</span>
  <span class="k">co_await</span> <span class="n">async</span><span class="o">::</span><span class="n">gather</span><span class="p">(</span><span class="n">aws</span><span class="p">);</span> <i class="conum" data-value="2"></i><b>(2)</b>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Wait for a variadic set of <a href="reference.html#awaitable">awaitables</a></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Wait for a vector of <a href="reference.html#awaitable">awaitables</a></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>gather</code> will invoke the functions of the <code>awaitable</code> as if used in a <code>co_await</code> expression.</p>
</div>
<div class="listingblock">
<div class="title">Signatures of join</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">extern</span> <span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">pv1</span><span class="p">,</span> <span class="n">pv2</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">system</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">system</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">r1</span> <span class="o">=</span> <span class="k">co_await</span> <span class="nf">gather</span><span class="p">(</span><span class="n">pv1</span><span class="p">,</span> <span class="n">pv2</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;&gt;</span> <span class="n">pvv</span><span class="p">;</span>
<span class="n">pmr</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">system</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;&gt;</span> <span class="n">r2</span> <span class="o">=</span>  <span class="k">co_await</span> <span class="nf">gather</span><span class="p">(</span><span class="n">pvv</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pi1</span><span class="p">,</span> <span class="n">pi2</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">system</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="n">monostate</span><span class="o">&gt;</span><span class="p">,</span>
           <span class="n">system</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="n">monostate</span><span class="o">&gt;</span><span class="p">,</span>
           <span class="n">system</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span>
           <span class="n">system</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">r3</span> <span class="o">=</span> <span class="k">co_await</span> <span class="nf">gather</span><span class="p">(</span><span class="n">pv1</span><span class="p">,</span> <span class="n">pv2</span><span class="p">,</span> <span class="n">pi1</span><span class="p">,</span> <span class="n">pi2</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">piv</span><span class="p">;</span>
<span class="n">pmr</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">system</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">r4</span> <span class="o">=</span> <span class="k">co_await</span> <span class="nf">gather</span><span class="p">(</span><span class="n">piv</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="gather-outline">Outline</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// Variadic gather</span>
<span class="k">template</span><span class="o">&lt;</span><span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span> <span class="n">Ct</span> <span class="o">=</span> <span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span><span class="o">::</span><span class="n">all</span><span class="p">,</span> <span class="n">awaitable</span><span class="p">...</span> <span class="n">Promise</span><span class="p">&gt;</span>
<span class="n"><em>awaitable</em></span> <span class="nf">gather</span><span class="p">(</span><span class="n">Promise</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">p</span><span class="p">);</span>

<span class="c1">// Ranged gather</span>
<span class="k">template</span><span class="o">&lt;</span><span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span> <span class="n">Ct</span> <span class="o">=</span> <span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span><span class="o">::</span><span class="n">all</span><span class="p">,</span> <span class="n">range</span><span class="o">&lt;</span><span class="n">awaitable</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="n"><em>awaitable</em></span> <span class="nf">gather</span><span class="p">(</span><span class="n">PromiseRange</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="p">);</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="join">async/join.hpp</h3>
<div class="paragraph">
<p>The <code>join</code> function can be used to <code>co_await</code> multiple <a href="reference.html#awaitable">awaitable</a> at once with properly connected cancellations.</p>
</div>
<div class="paragraph">
<p>The function will gather all completion and return them as values, unless an exception is thrown.
If an exception is thrown, all outstanding ops are cancelled (or detached if possible)
and the first exception gets rethrown.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>void</code> will be returned as <code>variant2::monostate</code> in the tuple, unless all awaitables yield void.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>It can be called as a variadic function with multiple <a href="reference.html#awaitable">Awaitable</a> or as on a range of <a href="reference.html#awaitable">awaitables</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">async</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">task1</span><span class="p">();</span>
<span class="n">async</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">task2</span><span class="p">();</span>

<span class="n">async</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">do_join</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">co_await</span> <span class="n">async</span><span class="o">::</span><span class="n">join</span><span class="p">(</span><span class="n">task1</span><span class="p">(),</span> <span class="n">task2</span><span class="p">());</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">async</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;&gt;</span> <span class="n">aws</span> <span class="p">{</span><span class="n">task1</span><span class="p">(),</span> <span class="n">task2</span><span class="p">()};</span>
  <span class="k">co_await</span> <span class="n">async</span><span class="o">::</span><span class="n">join</span><span class="p">(</span><span class="n">aws</span><span class="p">);</span> <i class="conum" data-value="2"></i><b>(2)</b>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Wait for a variadic set of <a href="reference.html#awaitable">awaitables</a></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Wait for a vector of <a href="reference.html#awaitable">awaitables</a></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>join</code> will invoke the functions of the <code>awaitable</code> as if used in a <code>co_await</code> expression.</p>
</div>
<div class="listingblock">
<div class="title">Signatures of join</div>
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">extern</span> <span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">pv1</span><span class="p">,</span> <span class="n">pv2</span><span class="p">;</span>
<span class="cm">/* void */</span> <span class="k">co_await</span> <span class="nf">join</span><span class="p">(</span><span class="n">pv1</span><span class="p">,</span> <span class="n">pv2</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;&gt;</span> <span class="n">pvv</span><span class="p">;</span>
<span class="cm">/* void */</span> <span class="k">co_await</span> <span class="nf">join</span><span class="p">(</span><span class="n">pvv</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pi1</span><span class="p">,</span> <span class="n">pi2</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">monostate</span><span class="p">,</span> <span class="n">monostate</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">r1</span> <span class="o">=</span> <span class="k">co_await</span> <span class="nf">join</span><span class="p">(</span><span class="n">pv1</span><span class="p">,</span> <span class="n">pv2</span><span class="p">,</span> <span class="n">pi1</span><span class="p">,</span> <span class="n">pi2</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">piv</span><span class="p">;</span>
<span class="n">pmr</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">r2</span> <span class="o">=</span> <span class="k">co_await</span> <span class="nf">join</span><span class="p">(</span><span class="n">piv</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="join-outline">Outline</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// Variadic join</span>
<span class="k">template</span><span class="o">&lt;</span><span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span> <span class="n">Ct</span> <span class="o">=</span> <span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span><span class="o">::</span><span class="n">all</span><span class="p">,</span> <span class="n">awaitable</span><span class="p">...</span> <span class="n">Promise</span><span class="p">&gt;</span>
<span class="n"><em>awaitable</em></span> <span class="nf">join</span><span class="p">(</span><span class="n">Promise</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">p</span><span class="p">);</span>

<span class="c1">// Ranged join</span>
<span class="k">template</span><span class="o">&lt;</span><span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span> <span class="n">Ct</span> <span class="o">=</span> <span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span><span class="o">::</span><span class="n">all</span><span class="p">,</span> <span class="n">range</span><span class="o">&lt;</span><span class="n">awaitable</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="n"><em>awaitable</em></span> <span class="nf">join</span><span class="p">(</span><span class="n">PromiseRange</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Selecting an on empty range will cause an exception.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="wait_group">async/wait_group.hpp</h3>
<div class="paragraph">
<p>The <code>wait_group</code> function can be used to manage
multiple coroutines of type <code>promise&lt;void&gt;</code>.
It works out of the box with <a href="reference.html#with">async/with.hpp</a>, by having the matching <code>await_exit</code> member.</p>
</div>
<div class="paragraph">
<p>Essentially, a <code>wait_group</code> is a dynamic list of
promises that has a  <code>select</code> function (<code>wait_one</code>),
a <code>gather</code> function (<code>wait_all</code>) and will clean up on scope exit.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">struct</span> <span class="nc">wait_group</span>
<span class="p">{</span>
    <span class="c1">// create a wait_group</span>
    <span class="k">explicit</span>
    <span class="n">wait_group</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span> <span class="n">normal_cancel</span> <span class="o">=</span> <span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span><span class="o">::</span><span class="n">none</span><span class="p">,</span>
               <span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span> <span class="n">exception_cancel</span> <span class="o">=</span> <span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span><span class="o">::</span><span class="n">all</span><span class="p">);</span>

    <span class="c1">// insert a task into the group</span>
    <span class="kt">void</span> <span class="n">push_back</span><span class="p">(</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">);</span>

    <span class="c1">// the number of tasks in the group</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">// remove completed tasks without waiting (i.e. zombie tasks)</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">reap</span><span class="p">();</span>
    <span class="c1">// cancel all tasks</span>
    <span class="kt">void</span> <span class="n">cancel</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span> <span class="n">ct</span> <span class="o">=</span> <span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span><span class="o">::</span><span class="n">all</span><span class="p">);</span>
    <span class="c1">// wait for one task to complete.</span>
    <span class="n"><em>wait_one_op</em></span> <span class="n">wait_one</span><span class="p">();</span>
    <span class="c1">// wait for all tasks to complete</span>
    <span class="n"><em>wait_op</em></span> <span class="n">wait</span><span class="p">();</span>
    <span class="c1">// wait for all tasks to complete</span>
    <span class="n"><em>wait_op</em></span> <span class="k">operator</span> <span class="k">co_await</span> <span class="p">();</span>
    <span class="c1">// when used with <code>with</code> , this will receive the exception</span>
    <span class="c1">// and wait for the completion</span>
    <span class="c1">// if <code>ep</code> is set, this will use the <code>exception_cancel</code> level,</span>
    <span class="c1">// otherwise the <code>normal_cancel</code> to cancel all promises.</span>
    <span class="n"><em>wait_op</em></span> <span class="n">await_exit</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception_ptr</span> <span class="n">ep</span><span class="p">);</span>
<span class="p">};</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spawn">async/spawn.hpp</h3>
<div class="paragraph">
<p>The <code>spawn</code> functions allow to run <a href="reference.html#task">task</a> on an asio <code>executor</code>/<code>execution_context</code>
and consume the result with a <a href="https://www.boost.org/doc/libs/1_83_0/doc/html/boost_asio/overview/model/completion_tokens.html">completion token</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">auto</span> <span class="nf">spawn</span><span class="p">(</span><span class="n">Context</span> <span class="o">&amp;</span> <span class="n">context</span><span class="p">,</span> <span class="n">task</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">,</span> <span class="n">CompletionToken</span><span class="o">&amp;&amp;</span> <span class="n">token</span><span class="p">);</span>
<span class="k">auto</span> <span class="nf">spawn</span><span class="p">(</span><span class="n">Executor</span> <span class="n">executor</span><span class="p">,</span> <span class="n">task</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">,</span> <span class="n">CompletionToken</span><span class="o">&amp;&amp;</span> <span class="n">token</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Spawn will dispatch it&#8217;s initiartion and post the completion. S
That makes it safe to use task to run the task on another executor
and consume the result on the current one with <a href="reference.html#use_op">use_op</a>.</p>
</div>
<div class="sect3">
<h4 id="example_2">Example</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">async</span><span class="o">::</span><span class="n">task</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">work</span><span class="p">();</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="n">asio</span><span class="o">::</span><span class="n">io_context</span> <span class="n">ctx</span><span class="p">{</span><span class="n">BOOST_ASIO_CONCURRENCY_HINT_1</span><span class="p">};</span>
  <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">spawn</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">work</span><span class="p">(),</span> <span class="n">asio</span><span class="o">::</span><span class="n">use_future</span><span class="p">);</span>
  <span class="n">ctx</span><span class="p">.</span><span class="n">run</span><span class="p">();</span>

  <span class="k">return</span> <span class="n">f</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The caller needs to make sure that the executor is not running on multiple threads
concurrently, e,g, by using a single-threaded <code>asio::io_context</code> or a <code>strand</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="run">async/run.hpp</h3>
<div class="paragraph">
<p>The <code>run</code> function is similar to <a href="reference.html#spawn">spawn</a> but running synchronously.
It will internally setup an execution context and the memory resources.</p>
</div>
<div class="paragraph">
<p>This can be useful when integrating a piece of async code into a synchronous application.</p>
</div>
<div class="sect3">
<h4 id="run-outline">Outline</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// Run the task and return it's value or rethrow any exception.</span>
<span class="n">T</span> <span class="nf">run</span><span class="p">(</span><span class="n">task</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">t</span><span class="p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="run-example">Example</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">async</span><span class="o">::</span><span class="n">task</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">work</span><span class="p">();</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">run</span><span class="p">(</span><span class="n">work</span><span class="p">());</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="thread">async/thread.hpp</h3>
<div class="paragraph">
<p>The thread type is another way to create an environment that is similar to <code>main</code>, but doesn&#8217;t use a <code>signal_set</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">async</span><span class="o">::</span><span class="kr">thread</span> <span class="nf">my_thread</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">exec</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">async</span><span class="o">::</span><span class="n">this_coro</span><span class="o">::</span><span class="n">executor</span><span class="p">;</span>             <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="n">asio</span><span class="o">::</span><span class="n">steady_timer</span> <span class="n">tim</span><span class="p">{</span><span class="n">exec</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">50</span><span class="p">)};</span> <i class="conum" data-value="2"></i><b>(2)</b>
  <span class="k">co_await</span> <span class="n">tim</span><span class="p">.</span><span class="n">async_wait</span><span class="p">(</span><span class="n">async</span><span class="o">::</span><span class="n">use_op</span><span class="p">);</span>                      <i class="conum" data-value="3"></i><b>(3)</b>
  <span class="k">co_return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>get the executor <code>thread</code> running on</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Use it with an asio object</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>co_await</code> an async operation</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To use a thread you can use it like a <code>std::thread</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">thr</span> <span class="o">=</span> <span class="n">my_thread</span><span class="p">();</span>
  <span class="n">thr</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A thread is also an <code>awaitable</code> (including cancellation).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">async</span><span class="o">::</span><span class="n">main</span> <span class="nf">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">thr</span> <span class="o">=</span> <span class="n">my_thread</span><span class="p">();</span>
  <span class="k">co_await</span> <span class="n">thr</span><span class="p">;</span>
  <span class="k">co_return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Destructing a detached thread will cause a hard stop (<code>io_context::stop</code>) and join the thread.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Nothing in this library, except for awaiting a <a href="reference.html#thread">async/thread.hpp</a> and <a href="reference.html#spawn">async/spawn.hpp</a>, is thread-safe.
If you need to transfer data across threads, you&#8217;ll need a thread-safe utility like <a href="https://www.boost.org/doc/libs/master/doc/html/boost_asio/reference/experimental__basic_concurrent_channel.html"><code>asio::conrurrenct_channel</code></a>.
You cannot share any async primitives between threads,
with the sole exception of being able to <a href="reference.html#spawn">spawn</a> a <a href="reference.html#task">task</a> onto another thread&#8217;s executor.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="executor_5">Executor</h4>
<div id="thread-executor" class="paragraph">
<p>It will also create an <code>asio::io_context</code> to run on, which you can get through the <code>this_coro::executor</code>.
It will be assigned to the <code>async::this_thread::get_executor()</code> .</p>
</div>
</div>
<div class="sect3">
<h4 id="memory_resource_5">Memory Resource</h4>
<div id="thread-allocator" class="paragraph">
<p>It also creates a memory resource that will be used as a default for internal memory allocations.
It will be assigned to the <code>thread_local</code> to the  <code>async::this_thread::get_default_resoruce()</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="thread-outline">Outline</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">struct</span> <span class="nc">thread</span>
<span class="p">{</span>
  <span class="c1">// Send a cancellation signal</span>
  <span class="kt">void</span> <span class="n">cancel</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span> <span class="n">type</span> <span class="o">=</span> <span class="n">asio</span><span class="o">::</span><span class="n">cancellation_type</span><span class="o">::</span><span class="n">all</span><span class="p">);</span>

  <span class="c1">// Add the functions similar to `std::thread`</span>
  <span class="kt">void</span> <span class="n">join</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="n">joinable</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="n">detach</span><span class="p">();</span>
  <span class="c1">// Allow the thread to be awaited</span>
  <span class="k">auto</span> <span class="k">operator</span> <span class="k">co_await</span><span class="p">()</span> <span class="o">&amp;-&gt;</span> <span class="n">detail</span><span class="o">::</span><span class="n">thread_awaitable</span><span class="p">;</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="k">auto</span> <span class="k">operator</span> <span class="k">co_await</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">-&gt;</span> <span class="n">detail</span><span class="o">::</span><span class="n">thread_awaitable</span><span class="p">;</span> <i class="conum" data-value="2"></i><b>(2)</b>

  <span class="c1">// Stops the io_context &amp; joins the executor</span>
  <span class="o">~</span><span class="kr">thread</span><span class="p">();</span>
  <span class="c1">/// Move constructible</span>
  <span class="kr">thread</span><span class="p">(</span><span class="kr">thread</span> <span class="o">&amp;&amp;</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

  <span class="k">using</span> <span class="n">executor_type</span> <span class="o">=</span> <span class="n">executor</span><span class="p">;</span>

  <span class="k">using</span> <span class="n">id</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">id</span><span class="p">;</span>
  <span class="n">id</span> <span class="n">get_id</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

  <span class="n">executor_type</span> <span class="n">get_executor</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Supports <a href="reference.html#interrupt_await">Interrupt Wait</a></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Always forward cancel</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="thread-promise">Promise</h4>
<div class="paragraph">
<p>The thread promise has the following properties.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="reference.html#promise_cancellation_base">Cancellation state</a></p>
</li>
<li>
<p><a href="reference.html#promise_throw_if_cancelled_base">Throw if cancelled</a></p>
</li>
<li>
<p><a href="reference.html#enable_awaitables">Enable awaitables</a></p>
</li>
<li>
<p><a href="reference.html#enable_await_allocator">Await Allocator</a></p>
</li>
<li>
<p><a href="reference.html#enable_await_executor">Await Executor</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="result">async/result.hpp</h3>
<div class="paragraph">
<p>Awaitables can be modified to return <code>system::result</code> or
<code>std::tuple</code> instead of using exceptions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// value only</span>
<span class="n">T</span> <span class="n">res</span> <span class="o">=</span> <span class="k">co_await</span> <span class="nf">foo</span><span class="p">();</span>

<span class="c1">// as result</span>
<span class="n">system</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">exception_ptr</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">async</span><span class="o">::</span><span class="n">as_result</span><span class="p">(</span><span class="n">foo</span><span class="p">());</span>

<span class="c1">// as tuple</span>
<span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">exception_ptr</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">async</span><span class="o">::</span><span class="n">as_tuple</span><span class="p">(</span><span class="n">foo</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Awaitables can also provide custom ways to handle results and tuples,
by providing <code>await_resume</code> overloads using <code>async::as_result_tag</code> and <code>async::as_tuple_tag</code>.:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n"><em>your_result_type</em></span> <span class="nf">await_resume</span><span class="p">(</span><span class="n">async</span><span class="o">::</span><span class="n">as_result_tag</span><span class="p">);</span>
<span class="n"><em>your_tuple_type</em></span>  <span class="nf">await_resume</span><span class="p">(</span><span class="n">async</span><span class="o">::</span><span class="n">as_tuple_tag</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This allows an awaitable to provide other error types than <code>std::exception_ptr</code>,
for example <code>system::error_code</code>. This is done by <a href="reference.html#op">op</a> and <a href="reference.html#channel">channel</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// example of an op with result system::error_code, std::size_t</span>
<span class="n">system</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span>                 <span class="n">await_resume</span><span class="p">(</span><span class="n">async</span><span class="o">::</span><span class="n">as_result_tag</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">await_resume</span><span class="p">(</span><span class="n">async</span><span class="o">::</span><span class="n">as_tuple_tag</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Awaitables are still allowed to throw exceptions, e.g. for critical exceptions such as OOM.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="async_for">async/async_for.hpp</h3>
<div class="paragraph">
<p>For types like generators a <code>BOOST_ASYNC_FOR</code> macro is provided, to emulate an <code>async for</code> loop.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="n">async</span><span class="o">::</span><span class="n">generator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">gen</span><span class="p">();</span>

<span class="n">async</span><span class="o">::</span><span class="n">main</span> <span class="nf">co_main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">BOOST_ASYNC_FOR</span><span class="p">(</span><span class="k">auto</span> <span class="n">i</span><span class="p">,</span> <span class="n">gen</span><span class="p">())</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Generated value %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

    <span class="k">co_return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The requirement is that the <a href="reference.html#awaitable">awaitable</a> used in the for loop has an <code>operator bool</code> to check if it
can be awaited again. This is the case for <a href="reference.html#generator">generator</a> and <a href="reference.html#promise">promise</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="error">async/error.hpp</h3>
<div class="paragraph">
<p>In order to make errors easier to manage, async provides an <code>error_category</code> to be used with
<code>boost::system::error_code</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">enum</span> <span class="k">class</span> <span class="nc">error</span>
<span class="p">{</span>
  <span class="n">moved_from</span><span class="p">,</span>
  <span class="n">detached</span><span class="p">,</span>
  <span class="n">completed_unexpected</span><span class="p">,</span>
  <span class="n">wait_not_ready</span><span class="p">,</span>
  <span class="n">already_awaited</span><span class="p">,</span>
  <span class="n">allocation_failed</span>
<span class="p">};</span>

<span class="n">system</span><span class="o">::</span><span class="n">error_category</span> <span class="o">&amp;</span> <span class="n">async_category</span><span class="p">();</span>
<span class="n">system</span><span class="o">::</span><span class="n">error_code</span> <span class="n">make_error_code</span><span class="p">(</span><span class="n">error</span> <span class="n">e</span><span class="p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="config">async/config.hpp</h3>
<div class="paragraph">
<p>The config adder allows to config some implementation details of boost.async.</p>
</div>
<div class="sect3">
<h4 id="executor_type">executor_type</h4>
<div class="paragraph">
<p>The executor type defaults to <code>boost::asio::any_io_executor</code>.</p>
</div>
<div class="paragraph">
<p>You can set it to <code>boost::asio::any_io_executor</code> by defining <code>BOOST_ASYNC_CUSTOM_EXECUTOR</code>
and adding a <code>boost::async::executor</code> type yourself.</p>
</div>
<div class="paragraph">
<p>Alternatively, <code>BOOST_ASYNC_USE_IO_CONTEXT</code> can be defined
to set the executor to <code>boost::asio::io_context::executor_type</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="pmr">pmr</h4>
<div class="paragraph">
<p>Boost.async can be used with different pmr implementations, defaulting to <code>std::pmr</code>.</p>
</div>
<div class="paragraph">
<p>The following macros can be used to configure it:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>BOOST_ASYNC_USE_STD_PMR</code></p>
</li>
<li>
<p><code>BOOST_ASYNC_USE_BOOST_CONTAINER_PMR</code></p>
</li>
<li>
<p><code>BOOST_ASYNC_USE_CUSTOM_PMR</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you define <code>BOOST_ASYNC_USE_CUSTOM_PMR</code> you will need to provide a <code>boost::async::pmr</code> namespace,
that is a drop-in replacement for <code>std::pmr</code>.</p>
</div>
<div class="paragraph">
<p>Alternatively, the <code>pmr</code> use can be disabled with</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>BOOST_ASYNC_NO_PMR</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In this case, async will use a non-pmr monotonic resource for the
synchronization functions (<a href="reference.html#select">select</a>, <a href="reference.html#gather">gather</a> and <a href="reference.html#join">join</a>).</p>
</div>
<div class="paragraph">
<p><code>use_op</code> uses a small-buffer-optimized resource which&#8217;s size can be set by defining
<code>BOOST_ASYNC_SBO_BUFFER_SIZE</code> and defaults to 4096 bytes.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="leaf">async/leaf.hpp</h3>
<div class="paragraph">
<p>Async provides integration with boost.leaf.
It provides functions similar to leaf that take an <a href="reference.html#awaitable">awaitables</a>
instead of a function object and return an <a href="reference.html#awaitable">awaitable</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="n">awaitable</span> <span class="n">TryAwaitable</span><span class="p">,</span> <span class="k">typename</span> <span class="o">...</span> <span class="nc">H</span> <span class="p">&gt;</span>
<span class="k">auto</span> <span class="nf">try_catch</span><span class="p">(</span><span class="n">TryAwaitable</span> <span class="o">&amp;&amp;</span> <span class="n">try_coro</span><span class="p">,</span> <span class="n">H</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">h</span> <span class="p">);</span>

<span class="k">template</span><span class="o">&lt;</span><span class="n">awaitable</span> <span class="n">TryAwaitable</span><span class="p">,</span> <span class="k">typename</span> <span class="o">...</span> <span class="nc">H</span> <span class="p">&gt;</span>
<span class="k">auto</span> <span class="nf">try_handle_all</span><span class="p">(</span><span class="n">TryAwaitable</span> <span class="o">&amp;&amp;</span> <span class="n">try_coro</span><span class="p">,</span> <span class="n">H</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">h</span> <span class="p">);</span>

<span class="k">template</span><span class="o">&lt;</span><span class="n">awaitable</span> <span class="n">TryAwaitable</span><span class="p">,</span> <span class="k">typename</span> <span class="o">...</span> <span class="nc">H</span> <span class="p">&gt;</span>
<span class="k">auto</span> <span class="nf">try_handle_some</span><span class="p">(</span><span class="n">TryAwaitable</span> <span class="o">&amp;&amp;</span> <span class="n">try_coro</span><span class="p">,</span> <span class="n">H</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">h</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>See the leaf documentation for details.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.boost.org/doc/libs/master/libs/leaf/doc/html/index.html#try_catch">try_catch</a></p>
</li>
<li>
<p><a href="https://www.boost.org/doc/libs/master/libs/leaf/doc/html/index.html#try_handle_all">try_handle_all</a></p>
</li>
<li>
<p><a href="https://www.boost.org/doc/libs/master/libs/leaf/doc/html/index.html#try_handle_some">try_handle_some</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="paragraph nav-footer">
<p>← Previous: <a href="design.html">Design</a> | ↑ Up: <a href="index.html">Documentation boost.async</a> | Next: <a href="technical_background.html">Technical Background</a> →</p>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 0.1<br>
Last updated 2023-09-05 16:09:54 +0800
</div>
</div>
</body>
</html>